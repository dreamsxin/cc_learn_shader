{
  "__type__": "cc.TextAsset",
  "_name": "poly2tri.d",
  "_objFlags": 0,
  "_native": "",
  "text": "﻿// Bundled type definitions for poly2tri.js\n// Project: http://github.com/r3mi/poly2tri.js/\n// Definitions by: Elemar Junior <https://github.com/elemarjr/>\n// Updated by: Rémi Turboult <https://github.com/r3mi>\n// TypeScript Version: 2.0\n\n/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n *\n * poly2tri.js (JavaScript port) (c) 2009-2017, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of Poly2Tri nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without specific\n *   prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n/**\n * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library\n * as a global variable `poly2tri` i.e. `window.poly2tri` in a browser.\n */\ndeclare namespace poly2tri {\n\n    /**\n     * poly2tri.js supports using custom point class instead of {@linkcode Point}.\n     * Any \"Point like\" object with `{x, y}` attributes is supported\n     * to initialize the SweepContext polylines and points\n     * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n     *\n     * poly2tri.js might add extra fields to the point objects when computing the\n     * triangulation : they are prefixed with `_p2t_` to avoid collisions\n     * with fields in the custom class.\n     *\n     * @example\n     *      const contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n     *      const swctx = new poly2tri.SweepContext(contour);\n     */\n    export interface IPointLike {\n        /** x coordinate */\n        x: number;\n        /** y coordinate */\n        y: number;\n    }\n\n    // Alias\n    export type XY = IPointLike;\n\n\n    /**\n     * poly2tri library version\n     */\n    export const VERSION: string;\n\n\n    /**\n     * A point {x, y}\n     */\n    export class Point implements XY {\n\n        /** x coordinate */\n        public x: number;\n        /** y coordinate */\n        public y: number;\n\n        /**\n         * Construct a point\n         * @example\n         *      const point = new poly2tri.Point(150, 150);\n         * @param x    coordinate (0 if undefined)\n         * @param y    coordinate (0 if undefined)\n         */\n        constructor(x?: number, y?: number);\n\n        /**\n         * For pretty printing\n         * @example\n         *      \"p=\" + new poly2tri.Point(5,42)\n         *      // → \"p=(5;42)\"\n         * @returns `\"(x;y)\"`\n         */\n        public toString(): string;\n\n        /**\n         * JSON output, only coordinates\n         * @example\n         *      JSON.stringify(new poly2tri.Point(1,2))\n         *      // → '{\"x\":1,\"y\":2}'\n         */\n        public toJSON(): any;\n\n        /**\n         * Creates a copy of this Point object.\n         * @return   new cloned point\n         */\n        public clone(): Point;\n\n        /**\n         * Set this Point instance to the origin `(0; 0)`\n         * @return this (for chaining)\n         */\n        public set_zero(): Point;\n\n        /**\n         * Set the coordinates of this instance.\n         * @param {number} x   coordinate\n         * @param {number} y   coordinate\n         * @return this (for chaining)\n         */\n        public set(x: number, y: number): Point;\n\n        /**\n         * Negate this Point instance. (component-wise)\n         * @return this (for chaining)\n         */\n        public negate(): Point;\n\n        /**\n         * Add another Point object to this instance. (component-wise)\n         * @param n - Point object.\n         * @return this (for chaining)\n         */\n        public add(n: XY): Point;\n\n        /**\n         * Subtract this Point instance with another point given. (component-wise)\n         * @param n - Point object.\n         * @return this (for chaining)\n         */\n        public sub(n: XY): Point;\n\n        /**\n         * Multiply this Point instance by a scalar. (component-wise)\n         * @param s   scalar.\n         * @return this (for chaining)\n         */\n        public mul(s: number): Point;\n\n        /**\n         * Return the distance of this Point instance from the origin.\n         * @return distance\n         */\n        public length(): number;\n\n        /**\n         * Normalize this Point instance (as a vector).\n         * @return The original distance of this instance from the origo.\n         */\n        public normalize(): number;\n\n        /**\n         * Test this Point object with another for equality.\n         * @param p - any \"Point like\" object with {x,y}\n         * @return `true` if same x and y coordinates, `false` otherwise.\n         */\n        public equals(p: XY): boolean;\n\n        /**\n         * Negate a point component-wise and return the result as a new Point object.\n         * @param p - any \"Point like\" object with {x,y}\n         * @return the resulting Point object.\n         */\n        public static negate(p: XY): Point;\n\n        /**\n         * Add two points component-wise and return the result as a new Point object.\n         * @param a - any \"Point like\" object with {x,y}\n         * @param b - any \"Point like\" object with {x,y}\n         * @return the resulting Point object.\n         */\n        public static add(a: XY, b: XY): Point;\n\n        /**\n         * Subtract two points component-wise and return the result as a new Point object.\n         * @param a - any \"Point like\" object with {x,y}\n         * @param b - any \"Point like\" object with {x,y}\n         * @return the resulting Point object.\n         */\n        public static sub(a: XY, b: XY): Point;\n\n        /**\n         * Multiply a point by a scalar and return the result as a new Point object.\n         * @param s - the scalar\n         * @param p - any \"Point like\" object with {x,y}\n         * @return the resulting Point object.\n         */\n        public static mul(s: number, p: XY): Point;\n\n        /**\n         * Perform the cross product on either two points (result is a scalar)\n         * or a point and a scalar (result is a point).\n         * This function requires two parameters, either may be a Point object or a\n         * number.\n         * @param  a - Point object or scalar.\n         * @param  b - Point object or scalar.\n         * @return a Point object or a number, depending on the parameters.\n         */\n        public static cross(a: XY, b: XY): number;\n        public static cross(a: XY, b: number): Point;\n        public static cross(a: number, b: XY): Point;\n        public static cross(a: number, b: number): number;\n\n        /**\n         * Point pretty printing. Delegates to the point's custom \"toString()\" method if exists,\n         * else simply prints x and y coordinates.\n         * @example\n         *      xy.toString({x:5, y:42})\n         *      // → \"(5;42)\"\n         * @example\n         *      xy.toString({x:5,y:42,toString:function() {return this.x+\":\"+this.y;}})\n         *      // → \"5:42\"\n         * @param p - point object with {x,y}\n         * @returns `\"(x;y)\"`\n         */\n        public static toString(p: XY): string;\n\n        /**\n         * Compare two points component-wise. Ordered by y axis first, then x axis.\n         * @param a - point object with {x,y}\n         * @param b - point object with {x,y}\n         * @return `< 0` if `a < b` ; `> 0` if `a > b` ; `0` otherwise.\n         */\n        public static compare(a: XY, b: XY): number;\n\n        /**\n         * Test two Point objects for equality.\n         * @param a - point object with {x,y}\n         * @param b - point object with {x,y}\n         * @return `true` if `a == b`, `false` otherwise.\n         */\n        public static equals(a: XY, b: XY): boolean;\n\n        /**\n         * Peform the dot product on two vectors.\n         * @param a - any \"Point like\" object with {x,y}\n         * @param b - any \"Point like\" object with {x,y}\n         * @return the dot product\n         */\n        public static dot(a: XY, b: XY): number;\n    }\n\n\n    /**\n     * Custom exception class to indicate invalid Point values\n     */\n    export class PointError extends Error {\n        /**\n         * Invalid points\n         */\n        public readonly points: ReadonlyArray<XY>;\n\n        /**\n         * Custom exception class to indicate invalid Point values\n         * @param message - error message\n         * @param points - invalid points\n         */\n        constructor(message: string, points: Array<XY>);\n    }\n\n\n    /**\n     * Triangle defined by 3 points\n     */\n    export class Triangle {\n        constructor(a: XY, b: XY, c: XY);\n\n        /**\n         * For pretty printing ex. `\"[(5;42)(10;20)(21;30)]\"`.\n         */\n        public toString(): string;\n\n        /**\n         * Get one vertice of the triangle.\n         * The output triangles of a triangulation have vertices which are references\n         * to the initial input points (not copies): any custom fields in the\n         * initial points can be retrieved in the output triangles.\n         * @example\n         *      const contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      swctx.triangulate();\n         *      const triangles = swctx.getTriangles();\n         *      typeof triangles[0].getPoint(0).id\n         *      // → \"number\"\n         * @param index - vertice index: 0, 1 or 2\n         * @returns point\n         */\n        public getPoint(index: 0 | 1 | 2): XY;\n\n        /**\n         * Get all 3 vertices of the triangle as an array\n         */\n        public getPoints(): [XY, XY, XY];\n\n        public containsPoint(point: XY): boolean;\n\n        public containsPoints(p1: XY, p2: XY): boolean;\n\n        public isInterior(): boolean;\n    }\n\n\n    /**\n     * SweepContext constructor option\n     */\n    export interface SweepContextOptions {\n        /**\n         * cloneArrays - if `true`, do a shallow copy of the Array parameters (contour, holes).\n         * Points inside arrays are never copied.\n         * Default is `false` : keep a reference to the array arguments, who will be modified in place.\n         */\n        cloneArrays?: boolean;\n    }\n\n\n    /**\n     * Triangulation context\n     */\n    export class SweepContext {\n\n        /**\n         * Constructor for the triangulation context.\n         * It accepts a simple polyline (with non repeating points),\n         * which defines the constrained edges.\n         *\n         * @example\n         *          const contour = [\n         *              new poly2tri.Point(100, 100),\n         *              new poly2tri.Point(100, 300),\n         *              new poly2tri.Point(300, 300),\n         *              new poly2tri.Point(300, 100)\n         *          ];\n         *          const swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n         * @example\n         *          const contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n         *          const swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n         *\n         * @param contour - array of point objects. The points can be either {@linkcode Point} instances,\n         *          or any \"Point like\" custom class with `{x, y}` attributes.\n         * @param options - constructor options\n         */\n        constructor(contour: Array<XY>, options?: SweepContextOptions);\n\n        /**\n         * Add a hole to the constraints\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      const hole = [\n         *          new poly2tri.Point(200, 200),\n         *          new poly2tri.Point(200, 250),\n         *          new poly2tri.Point(250, 250)\n         *      ];\n         *      swctx.addHole(hole);\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);\n         *\n         * @param polyline - array of \"Point like\" objects with {x,y}\n         */\n        public addHole(polyline: Array<XY>): SweepContext;\n\n        /**\n         * Add several holes to the constraints.\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      const holes = [\n         *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],\n         *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]\n         *      ];\n         *      swctx.addHoles(holes);\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      const holes = [\n         *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],\n         *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]\n         *      ];\n         *      swctx.addHoles(holes);\n         *\n         * @param holes - array of array of \"Point like\" objects with {x,y}\n         */\n        public addHoles(holes: Array<Array<XY>>): SweepContext;\n\n        /**\n         * Add a Steiner point to the constraints\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      const point = new poly2tri.Point(150, 150);\n         *      swctx.addPoint(point);\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      swctx.addPoint({x:150, y:150});\n         *\n         * @param point - any \"Point like\" object with {x,y}\n         */\n        public addPoint(point: XY): SweepContext;\n\n        /**\n         * Add several Steiner points to the constraints\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      const points = [\n         *          new poly2tri.Point(150, 150),\n         *          new poly2tri.Point(200, 250),\n         *          new poly2tri.Point(250, 250)\n         *      ];\n         *      swctx.addPoints(points);\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);\n         *\n         * @param points - array of \"Point like\" object with {x,y}\n         */\n        public addPoints(point: Array<XY>): SweepContext;\n\n        /**\n         * Triangulate the polygon with holes and Steiner points.\n         * Do this AFTER you've added the polyline, holes, and Steiner points\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      swctx.triangulate();\n         *      const triangles = swctx.getTriangles();\n         */\n        public triangulate(): SweepContext;\n\n        /**\n         * Get the bounding box of the provided constraints (contour, holes and\n         * Steinter points). Warning : these values are not available if the triangulation\n         * has not been done yet.\n         *\n         * @returns object with 'min' and 'max' Point\n         */\n        public getBoundingBox(): { min: Point; max: Point; };\n\n        /**\n         * Get result of triangulation.\n         * The output triangles have vertices which are references\n         * to the initial input points (not copies): any custom fields in the\n         * initial points can be retrieved in the output triangles.\n         *\n         * @example\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      swctx.triangulate();\n         *      const triangles = swctx.getTriangles();\n         * @example\n         *      const contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n         *      const swctx = new poly2tri.SweepContext(contour);\n         *      swctx.triangulate();\n         *      const triangles = swctx.getTriangles();\n         *      typeof triangles[0].getPoint(0).id\n         *      // → \"number\"\n         *\n         * @returns array of triangles\n         */\n        public getTriangles(): Array<Triangle>;\n    }\n\n}"
}